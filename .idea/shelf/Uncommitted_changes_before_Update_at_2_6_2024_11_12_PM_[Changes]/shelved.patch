Index: AVL Tree/Implement.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Abstract.h\"\r\n#include <iostream>\r\nusing namespace std;\r\nclass AVLTree: public Abstract{\r\n    static Node* createNode(int num){\r\n        return new Node{num, 1, nullptr, nullptr};\r\n    }\r\n    static int max(int num1, int num2){\r\n        return (num1 > num2) ? num1 : num2;\r\n    }\r\n    static int heightNode(Node* node){\r\n        return (!node) ? 0 : node->height;\r\n    }\r\n    static Node* minimumValue(Node* node){\r\n        Node* curr = node;\r\n        while(curr->left)\r\n            curr = curr->left;\r\n        return curr;\r\n    }\r\n    /*\r\n     * These two functions are for rotating nodes ie making parent node A with child node B and C, as a child to either\r\n     * node B or node C\r\n    */\r\n    static Node* rotateLeft(Node* node){\r\n        cout << \"Rotating node \" << node->value << \" to the left\" << endl;\r\n        Node* tempRight = node->right, *tempRightLeft = tempRight->left;\r\n        tempRight->left = node;\r\n        node->right = tempRightLeft;\r\n        node->height = max(heightNode(node->left), heightNode(node->right)) + 1;\r\n        tempRight->height = max(heightNode(tempRight->right), heightNode(tempRight->left)) + 1;\r\n        return tempRight;\r\n    }\r\n    static Node* rotateRight(Node* node){\r\n        cout << \"Rotating node \" << node->value << \" to the right\" << endl;\r\n        Node* tempLeft = node->left, *tempLeftRight = tempLeft->right;\r\n        tempLeft->right = node;\r\n        node->left = tempLeftRight;\r\n        node->height = max(heightNode(node->left), heightNode(node->right)) + 1;\r\n        tempLeft->height = max(heightNode(tempLeft->left), heightNode(tempLeft->right)) + 1;\r\n        return tempLeft;\r\n    }\r\npublic:\r\n    Node* insertNode(Node* node, int num) override{\r\n        //We will insert the node the same as we insert a node in Binary Search Tree recursively.\r\n        if(node == nullptr)\r\n            return createNode(num);\r\n        else if(num >= node->value)\r\n            node->right = insertNode(node->right, num);\r\n        else if(num < node->value)\r\n            node->left = insertNode(node->left, num);\r\n        /*\r\n         * Updates the height of each node including its balanceFactor.\r\n         * We will rotate the nodes based on the balanceFactor ie if the balance factor is -1 > then we will rotate\r\n         * either to the right or right and left, else if 1 < then we will rotate to the left or left and right\r\n         * depending on the value inserted.\r\n         */\r\n        node->height = max(heightNode(node->left), heightNode(node->right)) + 1;\r\n        int balanceFactor = heightNode(node->right) - heightNode(node->left);\r\n        if(balanceFactor < -1){\r\n            if(num < node->left->value){\r\n                return rotateRight(node);\r\n            }else if(num > node->left->value){\r\n                node->left = rotateLeft(node->left);\r\n                return rotateRight(node);\r\n            }\r\n        }else if (balanceFactor > 1){\r\n            if(num > node->right->value){\r\n                return rotateLeft(node);\r\n            }else if(num < node->right->value){\r\n                node->right = rotateRight(node->right);\r\n                return rotateLeft(node);\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    Node* deleteNode(Node* node, int num) override{\r\n        Node *returner = nullptr;\r\n        /*\r\n         * Searches the element recursively down the tree. If found, determine if it has 1 child, children or none.\r\n         * If none, return as nullptr, else if it has 1 child then make it a new child of the parent else if it has more\r\n         * than 1 child then search for the minimum value of its right child, swap the elements, then delete the swapped\r\n         * node.\r\n        */\r\n        if(!node)\r\n            return nullptr;\r\n        else if(num < node->value)\r\n            node->left = deleteNode(node->left, num);\r\n        else if(num > node->value)\r\n            node->right = deleteNode(node->right, num);\r\n        else{\r\n            if(node->left && node->right){\r\n                Node* temp = minimumValue(node->right);\r\n                node->value = temp->value;\r\n                node->right = deleteNode(node->right, node->value);\r\n            }else if(node->left)\r\n                returner = node->left;\r\n            else if(node->right)\r\n                returner = node->right;\r\n            else return nullptr;\r\n        }\r\n\r\n        //I assigned returner as a new child to its parent.\r\n        if(!returner){\r\n            returner = node;\r\n        }\r\n        /*\r\n         * Updates the height of each node including its balanceFactor.\r\n         * We will rotate the nodes based on the balanceFactor ie if the balance factor is -1 > then we will rotate\r\n         * either to the right or right and left, else if 1 < then we will rotate to the left or left and right\r\n         * depending on the value inserted.\r\n         */\r\n\r\n        returner->height = max(heightNode(returner->right), heightNode(returner->left)) + 1;\r\n        int balanceFactor = heightNode(returner->right) - heightNode(returner->left);\r\n        if(balanceFactor < -1){\r\n            if(num < node->left->value){\r\n                return rotateRight(node);\r\n            }else if(num > node->left->value){\r\n                node->left = rotateLeft(node->left);\r\n                return rotateRight(node);\r\n            }\r\n        }else if (balanceFactor > 1){\r\n            if(num > node->right->value){\r\n                return rotateLeft(node);\r\n            }else if(num < node->right->value){\r\n                node->right = rotateRight(node->right);\r\n                return rotateLeft(node);\r\n            }\r\n        }\r\n        return returner;\r\n    }\r\n    Node* searchNode(Node* node, int num) override{\r\n        /*\r\n         * Similar to how we search a node in insertNode and deleteNode, we will find the correct position of node A\r\n         * by comparing its element to the current node. If the number you're looking for is bigger than the number in\r\n         * the current node, traverse to the right otherwise traverse to the left until you'll hit a nullptr (which\r\n         * means the element did not exist) or a node that matches with the number you're looking for.\r\n        */\r\n        if(!node || node->value == num)\r\n            return node;\r\n        else if(num < node->value)\r\n            return searchNode(node->left, num);\r\n        else return searchNode(node->right, num);\r\n    }\r\n    int depth(Node* node, int num) override{\r\n        if(num < node->value)\r\n            return 1 + depth(node->left, num);\r\n        else if(num > node->value)\r\n            return 1 + depth(node->right, num);\r\n        else return 0;\r\n    }\r\n    int height(Node* node) override{\r\n        return max(heightNode(node->left), heightNode(node->right)) + 1;\r\n    }\r\n\r\n    //Pre-order Traversal\r\n    void printPR(Node* node) override{\r\n        if(node){\r\n            cout << node->value << \" \";\r\n            printPR(node->left);\r\n            printPR(node->right);\r\n        }\r\n    }\r\n    //Inorder Traversal\r\n    void printI(Node* node) override{\r\n        if(node){\r\n            printI(node->left);\r\n            cout << node->value << \" \";\r\n            printI(node->right);\r\n        }\r\n    }\r\n    //Post-order Traversal\r\n    void printPO(Node* node) override{\r\n        if(node){\r\n            printPO(node->left);\r\n            printPO(node->right);\r\n            cout << node->value << \" \";\r\n        }\r\n    }\r\n};
===================================================================
diff --git a/AVL Tree/Implement.h b/AVL Tree/Implement.h
--- a/AVL Tree/Implement.h	
+++ b/AVL Tree/Implement.h	
@@ -46,8 +46,7 @@
             return createNode(num);
         else if(num >= node->value)
             node->right = insertNode(node->right, num);
-        else if(num < node->value)
-            node->left = insertNode(node->left, num);
+        else node->left = insertNode(node->left, num);
         /*
          * Updates the height of each node including its balanceFactor.
          * We will rotate the nodes based on the balanceFactor ie if the balance factor is -1 > then we will rotate
